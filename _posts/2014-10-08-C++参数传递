---
layout: post
title: "C++ 参数传递"
description: "C++ Primer chapter 8 参数传递总结"
modified: 2014-10-08
category: C++
tags: C++
image:
  feature: abstract-5.jpg
comments: true
share: true
---

### 参数传递
&emsp;&emsp;这是在前几天看C++ Primer 的第8章时做的笔记，之前大致翻阅过C++ Primer,很多知识点，看过，也就忘记了。最近工程上，接触C++比较多，在做的过程中，再回过头来细细回顾这本经典，很多原来模糊的东西，都变得明晰，而很多所以然，也渐渐知晓。

#### 1. 常量引用
{% highlight C++ %}
func(const double &ra)
 {% endhighlight %}
* 当引用传递，又不想函数改变传进去的值时，可以使用常量引用，这种可以直接传递使用值。
* 普通值传递相当于是传递数据的副本，即需要复制原始结构的拷贝，会另外生成一份数据，故数据量大时，还是引用传递较为节省内存。

#### 2. 返回引用值
{% highlight C++ %}
free_throws & accumulate(free_throws & target, const free_throws & source) {
	return target;
}
{% endhighlight %}
* 将引用变量target传入了函数，该变量是可以被修改的，再返回对它的引用，如果函数头没有&，将返回对target指向变量的拷贝。
* 传统的返回机制，与按值传递函数参数类似，被调用函数返回在函数体内定义的临时变量时，该变量return以后存在一个临时存储单元中，再复制给上层调用函数的接收变量。
* 当返回为引用时，避免生成临时变量，效率更高。
* 函数体内定义的为临时变量，应该避免返回对临时变量的引用。当试图返回对临时变量的引用，子函数执行完毕，其声明的临时变量内存将被释放，即试图引用已经释放的内存，会引起程序奔溃。

#### 3.形参实参不匹配
* 形参实参不匹配：当将int实参传递给const double & 形参时，实参与形参类型不匹配，但是形参可以转变成引用类型（实参），程序将创建一个正确类型的临时变量，使用转换后的实参值来初始化它。然后传递一个指向该临时变量的引用。

#### 4. 基类引用
* 基类引用可以指向基类对象，也可以指向派生类对象，而无需进行强制类型转换。

#### 5. 对于使用传递的值而不做修改的函数
* 数据对象很小，如内置，则按值传递
* 数据对象是数组，只能使用指针传递，使用const指针
* 数据对象是较大结构，使用const指针或者const引用
* 类对象，使用const引用，这是C＋＋新增引用特性的原因

#### 6. 对于修改传递数据的函数
* 内置数据类型，使用指针
* 数组，使用指针
* 结构体，使用引用或者指针
* 类对象，使用引用

#### 7. 带默认值参数的函数
{% highlight C++ %}
char＊ left(const char *str, int n = 1)
 {% endhighlight %}
* 该函数返回一个新的字符串，将其返回类型设置为指向char的指针，希望原始字符串保持不变，加入const限定符，希望n的默认值为1，当传递n值，将覆盖1。
* 当为某个参数设置默认值，必须将其右边的所有参数都设置默认值。
* 当被调用函数返回的是指针或者引用，又不是传入的参数引用，则在该函数体内使用new创建了新的内存空间，在使用完返回的引用或者指针时，应该通过返回的指针/引用将其删除。