---
layout: post
category: Git
title: Git中基本操作
tags: 版本控制
---

&emsp;&emsp;前两天看王神面实习的简历，简历上面清晰地标出每个项目的tag似是一个很好的办法，既给面试官重点突出的感觉，也便于将面试中心集中，方便自己准备，而作为大型软件的开发，版本控制必不可少，将Git与SVN相关的东西做一个小总结。

<!--more-->

### 1. Git vs SVN

&emsp;&emsp;之前做实验室iPU的项目时，主要使用Subversion进行代码管理，现在自己的项目，基本使用Git；在不需要建多个分支的情况下，看起来二者差别不大；但一个分布式管理，一个集中式，还是倾向于使用Git，更安全。

* SVN分支代码只有一份，当需要开发新功能或者增加新版本或者修改一个复杂的Bug时，通常需要copy整份代码到本地一个目录，然后再手动添加到SVN上进行管理，比较麻烦；而Git可以建多个branches，分支独立，每次commit，只是对本地仓库的修改；
* SVN的log在服务器上，而Git的log在本地，方便查阅；
* Git可以无限在本地建分支，当我们在本地新建不同分支用于不同目的时，合并代码要比SVN上合并一堆工程copy更为方便；
* 在Git本地仓库根目录，只有一个.git文件，包含所有的管理信息，而SVN每个子目录都有.svn，修改文件冲突时麻烦；

### 2. 初始化一个新的代码仓库

经常使用的Git功能主要有以下几个：

* 初始化一个新的代码仓库，做一些适当配置；
* 开始或者停止跟踪某些文件；
* 暂存或者提交某些更新；
* 浏览项目的更新历史，查看某两次更新之间的差异；
* 如何从远程仓库pull数据下来，或者push数据到远程仓库；

{% highlight bash %}
  获取相应命令的帮助信息
$ git help config 
  初始化一个新的代码仓库，会生成.git目录
$ git init	
  告诉Git开始对某些文件进行跟踪             
$ git add README
  提交一个版本	        
$ git commit -m "message."	
{% endhighlight %}



### 3. 从现有仓库克隆

&emsp;&emsp;即将项目的Git仓库复制一份出来，Git 收取的是项目历史的所有数据（每一个文件的每一个版本），服务器上有的数据克隆之后本地也都有了。实际上，即便服务器的磁盘发生故障，用任何一个克隆出来的客户端都可以重建服务器上的仓库，回到当初克隆时的状态。`$ git clone git://github.com/schacon/grit.git mygrit` 克隆一个代码仓库，也可以不指定克隆下来存储代码仓库的文件夹名字。


### 4. 纪录每次更新到仓库

&emsp;&emsp;工作目录下面文件的两种状态：已跟踪或未跟踪。已跟踪的文件是指本来就被纳入版本控制管理的文件，在上次快照中有它们的记录，工作一段时间后，它们的状态可能是未更新，已修改或者已放入暂存区。而所有其他文件都属于未跟踪文件。它们既没有上次更新时的快照，也不在当前的暂存区域。

&emsp;&emsp;初次克隆某个仓库时，工作目录中的所有文件都属于已跟踪文件，且状态为未修改。在编辑过某些文件之后，Git 将这些文件标为已修改。我们逐步把这些修改过的文件放到暂存区域，直到最后一次性提交所有这些暂存起来的文件。

<figure>
    <img src="http://git-scm.com/figures/18333fig0201-tn.png" alt="">
    <figcaption>使用Git时的文件状态变化周期.</figcaption>
</figure>  

{% highlight bash %}
  确定哪些文件处于什么状态
$ git status
  开始跟踪file文件；修改某个文件之后，需要执行该命令将文件放入暂存区；  
$ git add file 
  可以创建.gitignore文件，不跟踪某些文件，自动忽略以o/a为后缀的文件；；       
$ cat .gitignore        
  *.[oa]            
  *~
  查看尚未暂存的文件更新了哪些部分；
$ git diff  
  将所有已经跟踪过的文件暂存起来并一块提交；        
$ git commit -a	 
  删除一个文件之后，再从未跟踪文件清单中将其清除；  
$ rm file
$ git rm file 
  相当于执行了`mv, git rm, git add`三条操作；
$ git mv file1 file2 
  将改动提交到远程仓库；
$ git push	
  从远程仓库将最新代码拉到本地；		  
$ git pull			  
{% endhighlight %}



	

