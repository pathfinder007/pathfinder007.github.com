---
layout: post
category: C++
title: C++中各种内置数据类型的长度以及表示范围
tags: C++
---

&emsp;&emsp;关于各种内置数据类型的size，一直以来都记得不是特别明确，这段时间都在写比较底层的OS直接操作硬件的C代码，倒也习惯了u8、u16、u32各种为满足操作系统平台移植性要求定义的数据类型;想起两年半以前在skyroam时候，看着GMate的系统代码，这是啥，这特么又是啥，那个迷茫的夏天。两年多的时间，收获了太多，不管是coding 上，还是其他。

<!--more-->

### 1. 有关int
&emsp;&emsp;int类型比较特殊，具体的字节数同机器字长和编译器有关。例如：在32为平台上（所谓32位平台是指通用寄存器的数据宽度是32）编写代码，int 类型分配4个字节，而在16位平台是则分配2个字节，那么在16位上编译出来的可执行文件，其中是为int分配2字节，而在32位平台上运行时，会按照4个字节来解析，显然会出错误的。 而对于非int，目前为止，所有的类型分配的字节数都是兼容的，即不同平台对于同一个类型分配相同的字节数。在代码中尽量避免使用int类型，根据不同的
需要可以用short,long,unsigned int 等代替。 

| 数据类型名称   | 字节数 |取值范围 | 
| ------       |:---:| ----:|
| int          | * |由操作系统决定，即与操作系统的＂字长＂有关|
| unsigned int | * |由操作系统决定，即与操作系统的＂字长＂有关|
| __int8       | 1 |–128 到 127|
| __int16      | 2 |–32,768 到 32,767|
| __int32      | 4 |–2,147,483,648 到 2,147,483,647|
| __int64      | 8 |–9,223,372,036,854,775,808 到 9,223,372,036,854,775,807|
| bool         | 1 |false 或 true|
| char         | 1 |–128 到 127|
| unsigned char| 1 |0 到 255|
| short        | 2 |–32,768 到 32,767|
|unsigned short| 2 |0 到 65,535|
|long          | 4 |–2,147,483,648 到 2,147,483,647|
|long long     | 8 |–9,223,372,036,854,775,808 到 9,223,372,036,854,775,807|
|unsigned long | 4 |0 到 4,294,967,295|
|enum          | * |由操作系统决定，即与操作系统的＂字长＂有关|
|float         | 4 |3.4E +/- 38 (7 digits)|
|double        | 8 |1.7E +/- 308 (15 digits)|
|long double   | 8 |1.7E +/- 308 (15 digits)|