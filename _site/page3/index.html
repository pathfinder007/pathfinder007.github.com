<!doctype html>
<!--[if lt IE 7]><html class="no-js lt-ie9 lt-ie8 lt-ie7" lang="en"> <![endif]-->
<!--[if (IE 7)&!(IEMobile)]><html class="no-js lt-ie9 lt-ie8" lang="en"><![endif]-->
<!--[if (IE 8)&!(IEMobile)]><html class="no-js lt-ie9" lang="en"><![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en"><!--<![endif]-->
<head>
<meta charset="utf-8">
<title>why so serious?</title>
<meta name="description" content="main page.">
<meta name="keywords" content="">


<!-- Open Graph -->

<meta property="og:locale" content="en_US">
<meta property="og:type" content="article">
<meta property="og:title" content="why so serious?">
<meta property="og:description" content="main page.">
<meta property="og:url" content="http://lambda.hk/page3/index.html">
<meta property="og:site_name" content="why so serious?">





<link rel="canonical" href="http://lambda.hk/page3/">
<link href="http://lambda.hk/feed.xml" type="application/atom+xml" rel="alternate" title="why so serious? Feed">


<!-- http://t.co/dKP3o1e -->
<meta name="HandheldFriendly" content="True">
<meta name="MobileOptimized" content="320">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<!-- For all browsers -->
<link rel="stylesheet" href="http://lambda.hk/assets/css/main.min.css">
<link rel="stylesheet" href="http://lambda.hk/assets/css/main.css">
<!-- Webfonts -->
<link href="http://fonts.googleapis.com/css?family=Lato:300,400,700,300italic,400italic" rel="stylesheet" type="text/css">

<meta http-equiv="cleartype" content="on">

<!-- Load Modernizr -->
<script src="http://lambda.hk/assets/js/vendor/modernizr-2.6.2.custom.min.js"></script>

<!-- Icons -->
<!-- 16x16 -->
<link rel="shortcut icon" href="http://lambda.hk/favicon.ico">
<!-- 32x32 -->
<link rel="shortcut icon" href="http://lambda.hk/favicon.png">
<!-- 57x57 (precomposed) for iPhone 3GS, pre-2011 iPod Touch and older Android devices -->
<link rel="apple-touch-icon-precomposed" href="http://lambda.hk/images/lambda57.png">
<!-- 72x72 (precomposed) for 1st generation iPad, iPad 2 and iPad mini -->
<link rel="apple-touch-icon-precomposed" sizes="72x72" href="http://lambda.hk/images/lambda72.png">
<!-- 114x114 (precomposed) for iPhone 4, 4S, 5 and post-2011 iPod Touch -->
<link rel="apple-touch-icon-precomposed" sizes="114x114" href="http://lambda.hk/images/lambda114.png">
<!-- 144x144 (precomposed) for iPad 3rd and 4th generation -->
<link rel="apple-touch-icon-precomposed" sizes="144x144" href="http://lambda.hk/images/lambda144.png">



</head>

<body id="post-index" class="feature">

<!--[if lt IE 9]><div class="upgrade"><strong><a href="http://whatbrowser.org/">Your browser is quite old!</strong> Why not upgrade to a different browser to better enjoy this site?</a></div><![endif]-->
<nav id="dl-menu" class="dl-menuwrapper" role="navigation">
	<button class="dl-trigger">Open Menu</button>
	<ul class="dl-menu">
		<li><a href="http://lambda.hk">Home</a></li>
		<li>
			<a href="#">About</a>
			<ul class="dl-submenu">
				<li>
					<img src="http://lambda.hk/images/avatar.png" alt="Pathfinder Mok photo" class="author-photo">
					<h4>Pathfinder Mok</h4>
					<p>Coding  &&  Reading</p>
					<p>Cycling &&  Hiking</p>
				</li>
				<!--li><a href="http://lambda.hk/about/">Learn More</a></li-->
				<li>
					<a href="mailto:xtcmhs@gmail.com"><i class="fa fa-envelope"></i> Email</a>
				</li>
				
				
				
				
				<li>
					<a href="http://github.com/pathfinder007"><i class="fa fa-github"></i> GitHub</a>
				</li>
				
				
				
				
				<li>
					<a href="http://www.renren.com/240122302/profile"><i class="fa fa-renren"></i> Renren</a>
				</li>
			</ul><!-- /.dl-submenu -->
		</li>
		<li>
			<a href="#">Posts</a>
			<ul class="dl-submenu">
				<li><a href="http://lambda.hk/posts/">All Posts</a></li>
				<li><a href="http://lambda.hk/tags/">All Tags</a></li>
			</ul>
		</li>
		<li><a href="http://lambda.hk"></a></li><li><a href="" target="_blank"></a></li>
	</ul><!-- /.dl-menu -->
</nav><!-- /.dl-menuwrapper -->


<div class="entry-header">
  
    <div class="entry-image">
      <img src="http://lambda.hk/images/abstract-10.jpg" alt="">
    </div><!-- /.entry-image -->
  
  <div class="header-title">
    <div class="header-title-wrap">
      <h1>why so serious?</h1>
      <h2></h2>
    </div><!-- /.header-title-wrap -->
  </div><!-- /.header-title -->
</div><!-- /.entry-header -->

<div id="main" role="main">
  <div class="right-nav">
    <div class="nav-unit">
	<h4>recent articles</h4>
    </div>
    <div class="visitor">
        <h4>visitors</h4>
    </div>
    <div class="the-map">
    <embed src="//rh.revolvermaps.com/f/g.swf" type="application/x-shockwave-flash" pluginspage="http://www.macromedia.com/go/getflashplayer" quality="high" wmode="window" allowScriptAccess="always" allowNetworking="all" width="220" height="220" flashvars="m=5&amp;i=78kqxwg8bw0&amp;r=false&amp;v=true&amp;b=000000&amp;n=false&amp;s=220&amp;c=ff0000"></embed><br /><img src="//rh.revolvermaps.com/js/c/78kqxwg8bw0.gif" width="1" height="1" alt="" />
    </div>
</div>
<a href="" target="_self" id="toTop" title="返回顶部" onclick="window.scrollTo(0,0);return false" style="display:none;"></a>
<script src="http://lambda.hk/assets/js/backtop.js"></script>

  
<article class="hentry">
  <header>
    <div class="entry-meta">
      <span class="entry-date date published updated"><time datetime="2014-10-06T00:00:00-04:00"><a href="http://lambda.hk/cv/Tracking-Learning-Detection/">October 06, 2014</a></time></span><span class="author vcard"></span>&nbsp; &bull; &nbsp;<span class="entry-comments"><a href="http://lambda.hk/cv/Tracking-Learning-Detection/#disqus_thread">Comment</a></span>
      
    </div><!-- /.entry-meta -->
    
      <h1 class="entry-title"><a href="http://lambda.hk/cv/Tracking-Learning-Detection/" rel="bookmark" title="Tracking Learning Detection" itemprop="url">Tracking Learning Detection</a></h1>
    
  </header>
  <div class="entry-content">
    <h3 id="tld">TLD简介.</h3>
<p>  TLD是一个可以实现在线学习、适应长时追踪的系统，这是英国萨里大学的捷克学生Zdenek Kalal在其攻读博士学位期间提出的一种新的单目标长时间跟踪算法，当时和尹叔两个人，借着作者在2010年发表的CVPR Best Paper “P-N Learning: Bootstrapping Binary Classifiers by Structural Constraints”, ZK关于TLD这个长时追踪系统，发了好几篇顶会，在作者 <a href="http://personal.ee.surrey.ac.uk/Personal/Z.Kalal/">主页</a> 上可以寻得。参照CSDN上, <a href="http://blog.csdn.net/zouxy09/article/details/7893011">zouxy09</a> 等人的博客，借着作者开放的 <a href="https://github.com/zk00006/OpenTLD">Matlab &amp;&amp; C++ 混编</a> 源代码，深入研究了一下这个框架。当时几乎把全部源码注释了一下，本着作者开放源代码的精神，将TLD的实现过程，简要记录一下。</p>

<h3 id="bounding-box-scan">Bounding Box Scan</h3>
<p>  首先，在第一帧，在图像上圈出要追踪的物体，然后进行全图像的一个扫描，代码中选取了21种尺度，每种尺度均进行上下左右10%的平移，在图像上打网格，用一个6xn的数组存储所有的样本，每一列6个参数，前4个为样本左上角以及右下角的4个坐标，后两个参数分别为样本所处的尺度特征的指针以及该尺度下每一行样本的数目。在我们的实验中，我的摄像头设置为640x480px，圈出的物体为52x132px. 我们一共得到121841个样本。</p>

<h3 id="generate-features">Generate Features</h3>
<p>  特征的提取，文章中作者称采用2bitBP进行提取，而代码中，其实是采用了1bitBP，作者文章是10年发的，代码是11年开源的，我猜作者是对精确度与计算复杂度之间做了一个权衡。实际上采用1bitBP进行特征提取，TLD的效果已经非常好。我们知道作者采用的核心分类器，随机蕨，每一层都是一个点对的比较，1bitBP，就是说，每一层取图像上的两个点进行比较，左边点比右边点颜色深，为1，否则为0，这就是一个特征的生成。由下图可以看出，作者提取的点对，都是在同一水平或者同一竖直方向上。在这一步对于10<em>10的随机蕨，用一个40</em>10的数组对特征提取的点坐标进行记录，存储是归一化的值，这样可以很方便地求取在任何尺度下，需要提取点对的具体坐标值。</p>
<figure>
	<img src="http://mhs-blog.qiniudn.com/gene_f.png" alt="" />
	<figcaption>Generate Features display.</figcaption>
</figure>

<h3 id="generate-postive--negtive-data">Generate Postive &amp;&amp; Negtive Data</h3>
<p>  接下来，对第一帧图像生成正负样本，首先计算扫描图像所得的每个patch与所选bounding box的重合度，选取重叠度小于0.2且方差比bounding box方差的50\%大的patch，作为负样本，赋予标签0.选取重叠度大于0.6的10样本，作为正样本，将其每个正样本进行20次仿射，正负1\%尺度变换，正负10旋转，方差为5的高斯噪声，一共得到200个正样本，赋予标签1. 这些即是作者文章中所说的，带标签的样本。</p>

<h3 id="initialize-random-ferns">Initialize Random Ferns</h3>
<p>   然后将带标签的正负样本，均分为两份，一份用作训练，一份测试，对随机蕨进行初始化。最终每个patch均会落入某一个叶子节点，用一个10位的二进制码表示。最后统计每个叶子节点的正负样本数以及正样本所占的比率，得到每个叶子节点为正样本的后验概率。再将测试样本依次通过各个fern，对于正样本，若10个fern产生的比率均值小于0.5，则判断错误，给相应的叶子节点正样本数加1，这个过程，可以反复测试，集合分类器的性能便能逐步提高，所以初始化时要花大量的时间，为了性能，在这一部也可以只用正样本进行初始化，毕竟每一帧，都会重复这样的学习过程。</p>
<figure>
	<img src="http://mhs-blog.qiniudn.com/random_forest.png" alt="" />
	<figcaption>Random Forest.</figcaption>
</figure>

<p>  在扫描图像所得的patch中，找出一个与bounding box重叠度最高的正样本，加上bounding box，在负样本中挑出50个，均进行归一化处理，0均值，单位方差，最终变为255*1的一维列向量，这个归一化处理，我觉得是为了降低光照的影响。将这些样本作为最近邻分类器的样本集，作者文章中提到，之前这个级联分类器只用了方差分类器与随机蕨，后来才在最后级联了一个最近邻分类器，可见这个分类器应该对系统性能，产生了比较大的影响。</p>

<h3 id="nearest-neighbor-classifier">Nearest Neighbor Classifier</h3>
<p>  最近邻分类器的作用，对通过随机蕨且被正确分类的patch，分别求其与最近邻分类器样本集中各个样本之间的归一化互相关系数(NCC)，若与正样本或者负样本之间的NCC均值大于0.95，则将该样本加入该样本集，表明TLD又学到了物体的一个新外观或者是学到了又一个背景图片。随着TLD系统运行时间的增加，这个样本集会逐渐增大，追踪检测性能提高的同时也对机器硬件提出了一个更大的要求。作者代码中计算NCC是调OpenCV的函数。</p>
<figure>
	<img src="http://mhs-blog.qiniudn.com/ncc.png" alt="" />
	<figcaption>NCC Calculation.</figcaption>
</figure>

<h3 id="tracking-and-evaluation">Tracking and Evaluation</h3>
<p>  对于追踪，以5px的间隔在第I帧的bounding box中取一个10x10的点阵。通过LK光流法对每个点进行追踪，为每个点建立FB error与NCC，并分别求出FB error与NCC的均值，找出FB error比均值小，NCC比均值大的点。找出的这些点即为置信度高的点，据此在第J帧图像上建立新的bounding box.当FB error的均值大于10px，表明追踪太不稳定，或者当bounding box出了图像边界，追踪失败。当追踪成功，为建立置信度模型，将检测到的bounding box作归一化处理，得到一个255x1的列向量，通过求NCC评估conf1，当conf1较大，则将valid置1，即追踪的bounding box可信。</p>

<h3 id="detection">Detection</h3>
<p>  对于检测，求图像的积分图与二次积分图，进而求每个patch块的方差，当其比bounding box方差的一半要小，则方差分类器将其过滤掉，这个阶段大约过滤掉一半的patch。对于通过方差分类器的patch，输入集合分类器，对每一棵fern，该patch均会落入一个叶子节点，由WEIGHT数组即可知道其为正样本的后验概率，10个fern求均值，返回给该patch在conf中对应位置。当样本检测完毕，寻找置信度大于阀值的patch返回100个置信度最大的。再将其通过最近邻分类器，找出置信度最大的一个patch，作为检测到的bounding box。</p>

<h3 id="finding-a-result">Finding a result</h3>
<p>  当追踪与检测同时有效，对检测所得的boxes，计算其两两之间overlap之和，根据重叠度对所得boxers进行最近邻聚类，并求每个聚类与追踪所得box的overlap以及置信度均值。找重合度小于0.5且置信度大于追踪所得结果置信度的聚类，即置信度高且远离追踪轨迹的检测结果。如果找到了一个这样的聚类，则对追踪器重新进行初始化，即将该box作为初始的追踪box，该box的置信度作为追踪器的置信度阀值。如果不只找到一个这样的聚类，即图像上有超过一个远离追踪位置的地方，有正样本聚集，找与追踪所得box的overlap超过0.7的检测box，用这些box的平均结果对追踪器进行重新初始化，即将该求得的box位置作为初始的追踪box。</p>

<p>  若追踪失败，检测有效，则将检测所得的patch聚类，若只有一个聚类，则用其检测到的bounding box对追踪器进行重新初始化；否则，认为检测失败。</p>

<p>  若检测失败但是追踪有效，则进行P-N learning，即对检测器进行更新。首先判断追踪所得box的置信度(tldNN)，当其与所选bounding box的相似度度小于0.5或者其box方差较小，不对检测器更新。否则，以追踪所得box为bounding box，在该帧图像上生成正样本，赋予标签1。与初始化时做法完全相同。仍然是找10个patch，不过仿射变换做10次。在该帧图像上生成负样本，赋予标签0，即与追踪所得box重叠度小于0.2且置信度最高的100个patch。计算追踪所得box与检测所得box的重合度，对重合度小于0.2的，亦作为负样本，对检测器进行更新，与初始化时机制相同。</p>

<h3 id="summary">Summary</h3>
<p>  以上，就是TLD的具体实现，作者的这个思路，还是很清楚的，主要有两个缺陷，TLD的学习需要时间，物体外观变化剧烈，且不再变回来，TLD将丢失物体，正负样本集是一个逐渐增大的过程，随着追踪的深入，对机器的性能要求很高，并没有一个很好的抛弃已学习到正负样本集的机制。</p>

  </div><!-- /.entry-content -->
</article><!-- /.hentry -->

<article class="hentry">
  <header>
    <div class="entry-meta">
      <span class="entry-date date published updated"><time datetime="2014-10-06T00:00:00-04:00"><a href="http://lambda.hk/algorithm/Sorting-Algorithm/">October 06, 2014</a></time></span><span class="author vcard"></span>&nbsp; &bull; &nbsp;<span class="entry-comments"><a href="http://lambda.hk/algorithm/Sorting-Algorithm/#disqus_thread">Comment</a></span>
      
    </div><!-- /.entry-meta -->
    
      <h1 class="entry-title"><a href="http://lambda.hk/algorithm/Sorting-Algorithm/" rel="bookmark" title="Sorting algorithm" itemprop="url">Sorting algorithm</a></h1>
    
  </header>
  <div class="entry-content">
    <h3 id="the-first-article-setup-my-blog">The first article, setup my blog.</h3>
<p>  之前一直有想法，搭一个独立博客，记录一下学习所得，顺便分享一些旅途中的经历，却一直没有下定决心。想着很多原来学习过程中总结过的东西，后来慢慢都丢了，未免有些遗憾。其实前几年还是挺喜欢写文章的，大都发布在各种社交网络，渐渐荒废。域名挑了个 lambda， 一则，这是希腊希腊字母，多年过去，我还是喜欢个性；二则，lambda象形所代表的孤独，低调，正应了了我的追求。是以为域名。</p>

<h3 id="section">几个概念</h3>
<ul>
  <li>内排序：在排序过程中，待排序的所有记录全部被放置在内存中。</li>
  <li>外排序：由于排序记录个数太多，不能同时放置在内存中，整个排序过程需要在内外存之间多次交换数据才能进行。</li>
  <li>内排序算法分类：(依据排序过程中借助的主要操作)，插入排序, 交换排序, 选择排序, 交换排序。</li>
  <li>复杂度为n**2：冒泡排序， 简单选择排序， 直接插入排序</li>
  <li>复杂度为n**3/2：希尔排序</li>
  <li>复杂度为nlogn：堆排序， 归并排序， 快速排序</li>
</ul>

<h3 id="section-1">冒泡排序</h3>

<h4 id="section-2">排序方法</h4>
<ul>
  <li>初始：R[1..n]为无序区</li>
  <li>第一趟扫描：依次比较(R[n]，R[n-1])，(R[n-1]，R[n-2])，…，(R[2]，R[1])；对于每对气泡(R[j+1]，R[j])，若
R[j+1].key&lt;R[j].key，则交换R[j+1]和R[j]的内容。第一趟扫描完毕，关键字最小的记录被放在最高位置R[1]上</li>
  <li>第二趟扫描：扫描R[2..n]，扫描完毕时，“次轻”的气泡漂浮到R[2]的位置上，最后经过n-1趟扫描，得到有序区R[1..n]</li>
  <li>小改进：若在某一趟排序中，未发现气泡位置的交换，则说明排序完毕。为此，可以引入一个布尔量exchange，每次排序开始前，
置为false，若排序过程中发生了交换，置为true，每趟排序结束检查exchange，若为false，则终止算法；否则继续。 </li>
</ul>

<p>完整代码:</p>

<div class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="kt">void</span> <span class="nf">BubbleSort</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="n">list</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">temp</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">flag</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">for</span><span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">len</span> <span class="o">&amp;&amp;</span> <span class="n">flag</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">flag</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">for</span><span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="n">len</span><span class="p">;</span> <span class="n">j</span> <span class="o">&gt;</span> <span class="n">i</span><span class="p">;</span> <span class="n">j</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span><span class="p">(</span><span class="n">list</span><span class="p">[</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">list</span><span class="p">[</span><span class="n">j</span><span class="p">])</span> <span class="p">{</span>
				<span class="n">temp</span> <span class="o">=</span> <span class="n">list</span><span class="p">[</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">];</span>
				<span class="n">list</span><span class="p">[</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">list</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>
				<span class="n">list</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">temp</span><span class="p">;</span>
				<span class="n">flag</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span></code></pre></div>

<h3 id="section-3">简单选择排序</h3>

<h4 id="section-4">排序方法</h4>
<ul>
  <li>冒泡排序需要不断交换元素位置，交换函数经常使用，封装成函数调用，函数调用需要压栈弹栈，时间开销大。
而选择排序找到合适的关键字再做交换，移动一次就能完成相应关键字排序定位。</li>
</ul>

<p>完整代码：</p>

<div class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="kt">void</span> <span class="nf">SelectSort</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="n">list</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">temp</span><span class="p">,</span> <span class="n">min</span><span class="p">;</span>
    <span class="k">for</span><span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">len</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">min</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
        <span class="k">for</span><span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">len</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span><span class="p">(</span><span class="n">list</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">list</span><span class="p">[</span><span class="n">min</span><span class="p">])</span> <span class="p">{</span>
                <span class="n">min</span> <span class="o">=</span> <span class="n">j</span><span class="p">;</span>
            <span class="p">}</span>   
        <span class="p">}</span>       
        <span class="k">if</span><span class="p">(</span><span class="n">i</span> <span class="o">!=</span> <span class="n">min</span><span class="p">)</span> <span class="p">{</span> 
            <span class="n">temp</span> <span class="o">=</span> <span class="n">list</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
            <span class="n">list</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">list</span><span class="p">[</span><span class="n">min</span><span class="p">];</span>
            <span class="n">list</span><span class="p">[</span><span class="n">min</span><span class="p">]</span> <span class="o">=</span> <span class="n">temp</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre></div>

<h3 id="section-5">直接插入排序</h3>

<h4 id="section-6">排序方法</h4>
<ul>
  <li>每次将一个待排序的记录，按其关键字大小插入到前面已经排好序的子序列中适当位置，直到全部记录插入完成。</li>
  <li>设数组为a[0..n-1], 初始时，a[0]自成有序区；将a[i]并入a[0..i-1]形成a[0..i]的有序区间。</li>
</ul>

<p>完整代码：</p>

<div class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="kt">void</span> <span class="nf">InsertSort</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="n">list</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">temp</span><span class="p">;</span>
	<span class="k">for</span><span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">len</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span><span class="p">(</span><span class="n">list</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">list</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="p">{</span>
			<span class="n">temp</span> <span class="o">=</span> <span class="n">list</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
			<span class="k">for</span><span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="n">j</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">list</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">temp</span><span class="p">;</span> <span class="n">j</span><span class="o">--</span><span class="p">)</span>
				<span class="n">list</span><span class="p">[</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">list</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>
			<span class="n">list</span><span class="p">[</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">temp</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span></code></pre></div>

<h3 id="section-7">希尔排序</h3>

<h4 id="section-8">排序方法</h4>
<ul>
  <li>实质是分组插入排序，又称为缩小增量排序，先将整个待排元素序列分割成若干子序列（由相隔某个增量的元素组成），
分别进行直接插入排序。待整个序列中元素基本有序（增量足够小），再对全体元素进行直接插入排序，在元素基本有序
的情况下，直接插入排序效率很高。</li>
  <li>R = [49, 38, 65, 97, 26, 13, 27, 49, 55, 4]，第一次gap为10 / 2 = 5，将数组分为5组，(49, 13), (38, 27)…
分组后为(13, 49), (27, 38)…</li>
  <li>R = [13, 27, 49, 55, 4, 49, 38, 65, 97, 26]，第二次gap为5 / 2 = 2，将数组分为2组，(13, 49, 4…)，(27, 55, 49…)，
进行直接插入排序后为：R = [4, 26, 13, 27, 38, 49, 49, 55, 97, 65]</li>
  <li>第三次gap = 1，进行最后一次插入排序，得最终序列。</li>
</ul>

<p>完整代码：</p>

<div class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="kt">void</span> <span class="nf">ShellSort</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="n">list</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">temp</span><span class="p">,</span> <span class="n">gap</span><span class="p">;</span>
	<span class="k">for</span><span class="p">(</span><span class="n">gap</span> <span class="o">=</span> <span class="n">len</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span> <span class="n">gap</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">;</span> <span class="n">gap</span> <span class="o">/=</span> <span class="mi">2</span><span class="p">)</span>
		<span class="k">for</span><span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">gap</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">for</span><span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="n">gap</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">len</span><span class="p">;</span> <span class="n">j</span><span class="o">+=</span><span class="n">gap</span><span class="p">)</span>
				<span class="k">if</span><span class="p">(</span><span class="n">list</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">list</span><span class="p">[</span><span class="n">j</span><span class="o">-</span><span class="n">gap</span><span class="p">])</span> <span class="p">{</span>
					<span class="kt">int</span> <span class="n">temp</span> <span class="o">=</span> <span class="n">list</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>
					<span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="n">j</span> <span class="o">-</span> <span class="n">gap</span><span class="p">;</span>
					<span class="k">while</span><span class="p">(</span><span class="n">k</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">list</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">temp</span><span class="p">)</span> <span class="p">{</span>
						<span class="n">list</span><span class="p">[</span><span class="n">k</span> <span class="o">+</span> <span class="n">gap</span><span class="p">]</span> <span class="o">=</span> <span class="n">list</span><span class="p">[</span><span class="n">k</span><span class="p">];</span>
						<span class="n">k</span> <span class="o">-=</span> <span class="n">gap</span><span class="p">;</span>
					<span class="p">}</span>
					<span class="n">list</span><span class="p">[</span><span class="n">k</span> <span class="o">+</span> <span class="n">gap</span><span class="p">]</span> <span class="o">=</span> <span class="n">temp</span><span class="p">;</span>
				<span class="p">}</span>	
		<span class="p">}</span>
<span class="p">}</span></code></pre></div>

<h3 id="section-9">堆排序</h3>

<h4 id="section-10">相关知识</h4>
<ul>
  <li>堆的概念：每个结点的值都大于或者等于其左右孩子结点的值，称为大顶堆；反之，小于或者等于，则为小顶堆。</li>
  <li>堆的存储：数组存储，i结点的父结点下标为(i-1)/2，左右结点下标为2<em>i+1, 2</em>i+2.</li>
  <li>堆的建立：数组具有对应树的表示形式，通过重新排列元素，可以建立一棵堆化的树。</li>
  <li>插入元素：新元素加入表层，随后树被更新以恢复堆次序。每次插入都将元素放在数组末尾，由于新数据的父节点
到根结点为一个有序数列，故可以使用直接插入排序将该新数据并入有序区间中。</li>
  <li>删除元素：删除总是发生在A[0]处，表中最后一个元素被用来填补空缺位置，结果树被更新以恢复堆条件。</li>
  <li>堆排序：将数组堆化后，堆中0号元素是堆中最小元素，取出该元素再执行下堆的删除操作。实际实现上，堆用数组
模拟，故堆化数组后，第一次将A[0]与A[n-1]交换，再对A[0..n-2]恢复堆，第二次将A[0]与A[n-2]交换，再对A[0..n-3]
恢复堆，重复直到A[0]与A[1]作交换，故操作完成后整个数组有序。</li>
</ul>

<h4 id="section-11">插入元素</h4>

<div class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="kt">void</span> <span class="nf">MinHeapFixup</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="n">list</span><span class="p">,</span> <span class="kt">int</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="p">(</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">temp</span> <span class="o">=</span> <span class="n">list</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
    <span class="k">while</span><span class="p">(</span><span class="n">j</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">i</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span><span class="p">(</span><span class="n">list</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">temp</span><span class="p">)</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="n">list</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">list</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>
        <span class="n">i</span> <span class="o">=</span> <span class="n">j</span><span class="p">;</span>
        <span class="n">j</span> <span class="o">=</span> <span class="p">(</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">list</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">temp</span><span class="p">;</span>
<span class="p">}</span></code></pre></div>

<h4 id="section-12">删除元素</h4>
<p>按定义，每次都只能删除第0个数据。为了便于重建堆，将最后一个数据的值赋给根结点，然后再从根结点开始进行一次
从上向下的调整。调整时先在左右儿子结点中找最小的，如果父结点比这个最小的子结点还小说明不需要调整了，反之
将父结点和它交换后再考虑后面的结点。相当于从根结点将一个数据的“下沉”过程。</p>

<div class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="kt">void</span> <span class="nf">MinHeapFixdown</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">[],</span> <span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="kt">int</span> <span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">j</span><span class="p">,</span> <span class="n">temp</span><span class="p">;</span>
	<span class="n">temp</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
	<span class="n">j</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">j</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="o">&amp;&amp;</span> <span class="n">a</span><span class="p">[</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">a</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
			<span class="n">j</span><span class="o">++</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">temp</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>
		<span class="n">i</span> <span class="o">=</span> <span class="n">j</span><span class="p">;</span>
		<span class="n">j</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">temp</span><span class="p">;</span>
<span class="p">}</span></code></pre></div>

<h4 id="section-13">堆化数组</h4>

<div class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="kt">void</span> <span class="nf">MakeMinHeap</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">[],</span> <span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>  
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">n</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">--</span><span class="p">)</span>  
        <span class="n">MinHeapFixdown</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span>  
<span class="p">}</span></code></pre></div>

<h4 id="section-14">排序方法</h4>

<div class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="kt">void</span> <span class="nf">MinheapsortTodescendarray</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">[],</span> <span class="kt">int</span> <span class="n">n</span><span class="p">)</span>  
<span class="p">{</span>  
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span><span class="o">--</span><span class="p">)</span>  
    <span class="p">{</span>  
        <span class="n">Swap</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>  
        <span class="n">MinHeapFixdown</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>  
    <span class="p">}</span>  
<span class="p">}</span></code></pre></div>

<h3 id="section-15">归并排序</h3>

<h4 id="section-16">相关知识</h4>
<ul>
  <li>利用分治法的思想实现排序，假设初始序列含有n个记录，则可以看作n个有序子序列，每个长度为1，
然后两两归并，得到n/2个长度为2或1的有序子序列，再两两归并，直到得到长度为n的有序序列。</li>
  <li>可以有递归，非递归两种实现。</li>
</ul>

<p>递归实现代码：</p>

<p>两个子序列归并操作：</p>

<div class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="kt">void</span> <span class="nf">MergeArray</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="n">list</span><span class="p">,</span> <span class="kt">int</span> <span class="n">first</span><span class="p">,</span> <span class="kt">int</span> <span class="n">mid</span><span class="p">,</span> <span class="kt">int</span> <span class="n">last</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">temp</span><span class="p">)</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">first</span><span class="p">,</span> <span class="n">j</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>  
    <span class="kt">int</span> <span class="n">m</span> <span class="o">=</span> <span class="n">mid</span><span class="p">,</span>   <span class="n">n</span> <span class="o">=</span> <span class="n">last</span><span class="p">;</span>  
    <span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>    
    <span class="k">while</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;=</span> <span class="n">m</span> <span class="o">&amp;&amp;</span> <span class="n">j</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">)</span>  
    <span class="p">{</span>  
        <span class="k">if</span> <span class="p">(</span><span class="n">list</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">list</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>  
            <span class="n">temp</span><span class="p">[</span><span class="n">k</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">list</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">];</span>  
        <span class="k">else</span>  
            <span class="n">temp</span><span class="p">[</span><span class="n">k</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">list</span><span class="p">[</span><span class="n">j</span><span class="o">++</span><span class="p">];</span>  
    <span class="p">}</span>  
    <span class="k">while</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;=</span> <span class="n">m</span><span class="p">)</span>  
        <span class="n">temp</span><span class="p">[</span><span class="n">k</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">list</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">];</span>  
      
    <span class="k">while</span> <span class="p">(</span><span class="n">j</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">)</span>  
        <span class="n">temp</span><span class="p">[</span><span class="n">k</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">list</span><span class="p">[</span><span class="n">j</span><span class="o">++</span><span class="p">];</span>  
      
    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">k</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>  
        <span class="n">list</span><span class="p">[</span><span class="n">first</span> <span class="o">+</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">temp</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>  
<span class="p">}</span></code></pre></div>

<p>递归调用：</p>

<div class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="kt">void</span> <span class="nf">MergeSort</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="n">list</span><span class="p">,</span> <span class="kt">int</span> <span class="n">first</span><span class="p">,</span> <span class="kt">int</span> <span class="n">last</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">temp</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">first</span> <span class="o">&lt;</span> <span class="n">last</span><span class="p">)</span>  
    <span class="p">{</span>  
        <span class="kt">int</span> <span class="n">mid</span> <span class="o">=</span> <span class="p">(</span><span class="n">first</span> <span class="o">+</span> <span class="n">last</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>  
        <span class="n">MergeSort</span><span class="p">(</span><span class="n">list</span><span class="p">,</span> <span class="n">first</span><span class="p">,</span> <span class="n">mid</span><span class="p">,</span> <span class="n">temp</span><span class="p">);</span>
        <span class="n">MergeSort</span><span class="p">(</span><span class="n">list</span><span class="p">,</span> <span class="n">mid</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">last</span><span class="p">,</span> <span class="n">temp</span><span class="p">);</span>
        <span class="n">MergeArray</span><span class="p">(</span><span class="n">list</span><span class="p">,</span> <span class="n">first</span><span class="p">,</span> <span class="n">mid</span><span class="p">,</span> <span class="n">last</span><span class="p">,</span> <span class="n">temp</span><span class="p">);</span>
    <span class="p">}</span> 
	<span class="k">else</span>
		<span class="n">temp</span><span class="p">[</span><span class="n">first</span><span class="p">]</span> <span class="o">=</span> <span class="n">list</span><span class="p">[</span><span class="n">first</span><span class="p">];</span> 
<span class="p">}</span></code></pre></div>

<ul>
  <li>时间复杂度：每趟归并需要把有序序列进行两两归并，耗费O(n)时间，由完全二叉树深渡为logn,故
时间复杂度为nlogn</li>
  <li>空间复杂度：归并过程中需要与原始记录序列同样数量的存储空间存放归并结果以及递归时深度为logn
的栈空间，空间复杂度为n+logn.</li>
</ul>

<p>非递归实现归并排序：
* 递归过程是将待排序集合一分为二，直至排序集合就剩下一个元素位置，然后不断的合并两个排好序的数组。
* 非递归思想为，将数组中的相邻元素两两配对。用merge函数将他们排序，构成n/2组长度为2的排序好的子数组段，
然后再将他们排序成长度为4的子数组段，如此继续下去，直至整个数组排好序。</p>

<p>具体代码实现：</p>

<div class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="kt">void</span> <span class="nf">MergeSort2</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="n">list</span><span class="p">,</span> <span class="kt">int</span> <span class="n">first</span><span class="p">,</span> <span class="kt">int</span> <span class="n">last</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">temp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">s</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">s</span> <span class="o">&lt;=</span> <span class="n">len</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="n">s</span> <span class="o">&lt;=</span> <span class="n">len</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">MergeArray</span> <span class="p">(</span><span class="n">list</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="o">+</span><span class="n">s</span><span class="o">/</span><span class="mi">2</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">i</span><span class="o">+</span><span class="n">s</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">temp</span><span class="p">);</span>
            <span class="n">i</span> <span class="o">+=</span> <span class="n">s</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">MergeArray</span> <span class="p">(</span><span class="n">list</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="o">+</span><span class="n">s</span><span class="o">/</span><span class="mi">2</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">len</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">temp</span><span class="p">);</span>
        <span class="n">s</span> <span class="o">*=</span> <span class="mi">2</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">MergeArray</span> <span class="p">(</span><span class="n">list</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">s</span><span class="o">/</span><span class="mi">2</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">len</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">temp</span><span class="p">);</span>
<span class="p">}</span></code></pre></div>

<h3 id="section-17">快速排序</h3>

<h4 id="section-18">相关知识</h4>
<ul>
  <li>先从数列中取出一个数作为基准数；分区过程，将比其大的数放在右边，小的数放在左边。</li>
  <li>再对左右空间重复此操作，直到各区间只有一个数。</li>
</ul>

<h4 id="section-19">算法实现</h4>
<ul>
  <li>从j开始向前找一个比X小或等于X的数。符合条件，挖出再填到上一个坑a[0]，i++;  这样一个坑a[0]就被搞定了，
但又形成了一个新坑，这次从i开始向后找一个大于X的数，符合条件，挖出再填到上一个坑中a[8]=a[3]; j–;</li>
  <li>重复上面的步骤，先从后向前找，再从前向后找，最后将X填入最后一个坑中。</li>
</ul>

<p>具体代码实现：</p>

<p>归并过程：</p>

<div class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="kt">int</span> <span class="nf">AdjustArray</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="n">list</span><span class="p">,</span> <span class="kt">int</span> <span class="n">l</span><span class="p">,</span> <span class="kt">int</span> <span class="n">r</span><span class="p">)</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">l</span><span class="p">,</span> <span class="n">j</span> <span class="o">=</span> <span class="n">r</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="n">list</span><span class="p">[</span><span class="n">l</span><span class="p">];</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">j</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">while</span><span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">j</span> <span class="o">&amp;&amp;</span> <span class="n">list</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">x</span><span class="p">)</span> 
			<span class="n">j</span><span class="o">--</span><span class="p">;</span>  
		<span class="k">if</span><span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">j</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">list</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">list</span><span class="p">[</span><span class="n">j</span><span class="p">];</span> 
			<span class="n">i</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">while</span><span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">j</span> <span class="o">&amp;&amp;</span> <span class="n">list</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">x</span><span class="p">)</span>
			<span class="n">i</span><span class="o">++</span><span class="p">;</span>  
		<span class="k">if</span><span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">j</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">list</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">list</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
			<span class="n">j</span><span class="o">--</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">list</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">i</span><span class="p">;</span>
<span class="p">}</span></code></pre></div>

<p>递归过程：</p>

<div class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="kt">void</span> <span class="nf">QuickSort</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="n">list</span><span class="p">,</span> <span class="kt">int</span> <span class="n">l</span><span class="p">,</span> <span class="kt">int</span> <span class="n">r</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">l</span> <span class="o">&lt;</span> <span class="n">r</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">AdjustArray</span><span class="p">(</span><span class="n">list</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">r</span><span class="p">);</span>
		<span class="n">QuickSort</span><span class="p">(</span><span class="n">list</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span> 
		<span class="n">QuickSort</span><span class="p">(</span><span class="n">list</span><span class="p">,</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">r</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span></code></pre></div>

<h3 id="reference">Reference.</h3>
<p>  本文参考了 <a href="http://blog.csdn.net/v_JULY_v">结构之法 算法之道</a>  以及  <a href="http://blog.csdn.net/morewindows/article">More Windows Blog</a>  的几篇文章，在此表示感谢。</p>

  </div><!-- /.entry-content -->
</article><!-- /.hentry -->


<div class="pagination">
  
    
      <a href="http://lambda.hk/page2" class="btn">Previous</a>
    
  
  <ul class="inline-list">
    <li>
      
        <a href="http://lambda.hk">1</a>
      
    </li>
    
      <li>
        
          <a href="http://lambda.hk/page2">2</a>
        
      </li>
    
      <li>
        
          <span class="current-page">3</span>
        
      </li>
    
  </ul>
  
    Next
  
</div><!-- /.pagination -->

</div><!-- /#main -->

<div class="footer-wrapper">
  <footer role="contentinfo">
    <span>&copy; 2014 Pathfinder Mok. Powered by Jekyll  using the HPSTR Theme.</span>

  </footer>
</div><!-- /.footer-wrapper -->

<script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
<script>window.jQuery || document.write('<script src="http://lambda.hk/assets/js/vendor/jquery-1.9.1.min.js"><\/script>')</script>
<script src="http://lambda.hk/assets/js/scripts.min.js"></script>
<!--script src="http://lambda.hk/assets/js/backtop.js"></script-->


          

</body>
</html>
